class Solution {
    public String minWindow(String s, String t) {
        /*1. Bruoteforce Approach- 
            1.count frequency of chars in t
            2.gen all substring of s
            3. Check if substring s[i..j] contains all chars of t
            */

        /* 2. Sliding window:- 
            a.use 2 pointers
            b. expand first pointer until it covers all characters of t
            c. shrink from left to make it as small as possible */

            if(s.length() < t.length()) return "";

             // frequency of required chars in t
        int[] need = new int[128];
        for (char c : t.toCharArray()) {
            need[c]++;
        }

        int[] window = new int[128];  // counts in current window
        int have = 0, needCount = t.length();
        int left = 0, minLen = Integer.MAX_VALUE;
        int start = 0;  // start index of best window

                // expand window with right pointer
        for (int right = 0; right < s.length(); right++) {
            char c = s.charAt(right);
            window[c]++;

            // if this char is useful (not extra)
            if (need[c] > 0 && window[c] <= need[c]) {
                have++;
            }

             // when window contains all of t
            while (have == needCount) {
                // check if smaller than best
                if (right - left + 1 < minLen) {
                    minLen = right - left + 1;
                    start = left;
                }

                // shrink from left
                char lc = s.charAt(left);
                window[lc]--;
                if (need[lc] > 0 && window[lc] < need[lc]) {
                    have--;
                }
                 left++;
            }
        }
        return minLen == Integer.MAX_VALUE ? "" : s.substring(start, start + minLen);


        
    }
}
